"""
Ed25519 Digital Signatures.

Ed25519 provides origin attribution for SPE proofs:
  - 128-bit security equivalent
  - Fast signing and verification
  - Small signatures (64 bytes)
  - Deterministic (same input always produces same signature)

IMPORTANT: Signing is OPTIONAL. SPE proofs are fully valid
without signatures. Signatures add origin attribution
("this proof was generated by a specific entity") but the
mathematical integrity (hashing + ledger) works independently.

Requires: pip install pynacl
"""

import base64
from typing import Dict, Optional

# PyNaCl is optional — signing degrades gracefully
try:
    from nacl.exceptions import BadSignatureError
    from nacl.signing import SigningKey, VerifyKey
    _NACL_AVAILABLE = True
except ImportError:
    _NACL_AVAILABLE = False
    SigningKey = None
    VerifyKey = None
    BadSignatureError = Exception


def nacl_available() -> bool:
    """Check if PyNaCl is installed and signing is available."""
    return _NACL_AVAILABLE


def sign_bytes(data: bytes, private_key_b64: str) -> Dict[str, str]:
    """
    Sign bytes using an Ed25519 private key.
    
    Args:
        data: The bytes to sign (typically canonical JSON of proof input)
        private_key_b64: Base64-encoded 32-byte Ed25519 seed
        
    Returns:
        Dict with 'algorithm', 'public_key', and 'signature_value'
        (all Base64-encoded where applicable)
        
    Raises:
        RuntimeError: If PyNaCl is not installed
    """
    if not _NACL_AVAILABLE:
        raise RuntimeError(
            "PyNaCl is required for signing. Install with: pip install pynacl"
        )

    sk = SigningKey(base64.b64decode(private_key_b64))
    sig = sk.sign(data).signature
    return {
        "algorithm": "ed25519",
        "public_key": base64.b64encode(sk.verify_key.encode()).decode("ascii"),
        "signature_value": base64.b64encode(sig).decode("ascii"),
    }


def verify_signature(
    data: bytes,
    signature_block: Dict[str, str],
    expected_pubkey_b64: Optional[str] = None,
) -> str:
    """
    Verify an Ed25519 signature.
    
    Args:
        data: The original signed bytes
        signature_block: Dict with 'algorithm', 'public_key', 'signature_value'
        expected_pubkey_b64: Optional expected public key for additional validation
        
    Returns:
        "VALID" — Signature is cryptographically valid
        "INVALID" — Signature does not match
        "UNKNOWN" — Cannot verify (PyNaCl not installed)
        "PUBKEY_MISMATCH" — Valid signature but wrong public key
    """
    if not _NACL_AVAILABLE:
        return "UNKNOWN"

    try:
        if signature_block.get("algorithm") != "ed25519":
            return "INVALID"

        pub_bytes = base64.b64decode(signature_block["public_key"])
        sig_bytes = base64.b64decode(signature_block["signature_value"])
        vk = VerifyKey(pub_bytes)
        vk.verify(data, sig_bytes)

        if expected_pubkey_b64:
            expected = base64.b64decode(expected_pubkey_b64)
            if pub_bytes != expected:
                return "PUBKEY_MISMATCH"

        return "VALID"

    except (BadSignatureError, KeyError, Exception):
        return "INVALID"
